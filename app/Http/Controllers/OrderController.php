<?php

namespace App\Http\Controllers;

use App\Http\Requests\OrderRequest;
use App\Models\Customer;
use App\Models\Event;
use App\Models\Order;
use App\Models\Venue;
use Illuminate\Http\Request;
use Illuminate\Support\Arr;

use Illuminate\Support\Facades\DB;
use Inertia\Inertia;

class OrderController extends Controller
{
    public function index()
    {
        $orders = Order::with([
            'customer:id,organizer',
            'venues:id,name',
            'event:id,event_type,code' // Include event relationship
        ])->orderBy('created_at', 'desc')->get();

        return Inertia::render('orders/index', compact('orders'));
    }

    public function create(Request $request)
    {
        // 1. Fetch all venues
        $venues = Venue::select('id', 'name')->get();

        // 2. Fetch all events for event type selection
        $events = Event::select('id', 'event_type', 'code')->orderBy('event_type', 'asc')->get();

        // 3. Fetch ALL existing bookings for ALL venues (not just selected ones)
        // This ensures the React component has all booking data to work with
        $bookings = [];
        $orders = Order::with('venues')->get(['id', 'start_date', 'end_date']);

        foreach ($orders as $order) {
            foreach ($order->venues as $venue) {
                $bookings[] = [
                    'venue_id' => $venue->id,
                    'start_date' => optional($order->start_date)->toDateString(), // Changed from 'start' to 'start_date'
                    'end_date' => optional($order->end_date)->toDateString(),     // Changed from 'end' to 'end_date'
                ];
            }
        }

        // 4. Fetch existing customers (only id & organizer)
        $customers = Customer::select('id', 'organizer')->orderBy('organizer', 'asc')->get();

        // 5. Render Inertia page with venues, events, bookings, customers & flash
        return Inertia::render('orders/create', [
            'venues' => $venues,
            'events' => $events, // Add events for selection
            'bookings' => $bookings,
            'customers' => $customers,
            'flash' => session('flash', []),
        ]);
    }

    public function store(OrderRequest $request)
    {
        $data = $request->validated();

        try {
            DB::beginTransaction();

            // 1) Resolve customer ID
            if ($data['customerOption'] === 'new') {
                $custId = Customer::create($data['customer'])->id;
            } else {
                $custId = $data['existing_customer_id'];
            }

            // 2) Validate event_id exists
            $event = Event::findOrFail($data['event_id']);

            // 3) Create the Order (single start/end on the order)
            $order = Order::create([
                'event_id' => $data['event_id'], // Add event_id
                'event_name' => $data['event_name'] ?? '—',
                'customer_id' => $custId,
                'status' => 0,
                'status_beo' => 0, // Initialize BEO status
                'start_date' => $data['start_date'],
                'end_date' => $data['end_date'],
                // custom_code will be automatically generated by the Order model's boot method
            ]);

            // 4) Attach venues (only order_id + venue_id)
            // Using sync() so you don't create duplicates if you revisit the form
            $order->venues()->sync($data['venues']);

            // 5) Load the event relationship for the response
            $order->load('event');

            DB::commit();

            return redirect()
                ->route('orders.index')
                ->with('flash', [
                    'message' => "Order created successfully with code: {$order->custom_code} ({$order->event->event_type})"
                ]);

        } catch (\Exception $e) {
            DB::rollBack();
            
            return redirect()
                ->back()
                ->withInput()
                ->with('flash', [
                    'error' => 'Failed to create order: ' . $e->getMessage()
                ]);
        }
    }

    public function show(Order $order)
    {
        // Load all necessary relationships including event
        $order->load([
            'customer', 
            'venues', 
            'event:id,event_type,code', 
            'schedules', 
            'beos'
        ]);

        return Inertia::render('orders/show', [
            'order' => $order
        ]);
    }

    public function edit(Order $order)
    {
        // Load relationships for editing
        $order->load([
            'customer', 
            'venues', 
            'event:id,event_type,code'
        ]);

        $venues = Venue::select('id', 'name')->get();
        $events = Event::select('id', 'event_type', 'code')->orderBy('event_type', 'asc')->get();
        $customers = Customer::select('id', 'organizer')->orderBy('organizer', 'asc')->get();

        return Inertia::render('orders/edit', [
            'order' => $order,
            'venues' => $venues,
            'events' => $events,
            'customers' => $customers
        ]);
    }

    public function update(OrderRequest $request, Order $order)
    {
        $data = $request->validated();

        try {
            DB::beginTransaction();

            // 1) Resolve customer ID if needed
            if ($data['customerOption'] === 'new') {
                $custId = Customer::create($data['customer'])->id;
            } else {
                $custId = $data['existing_customer_id'];
            }

            // 2) Validate event_id exists
            $event = Event::findOrFail($data['event_id']);

            // 3) Update the Order
            $order->update([
                'event_id' => $data['event_id'],
                'event_name' => $data['event_name'] ?? '—',
                'customer_id' => $custId,
                'start_date' => $data['start_date'],
                'end_date' => $data['end_date'],
            ]);

            // 4) Sync venues
            $order->venues()->sync($data['venues']);

            // 5) Load the event relationship for the response
            $order->load('event');

            DB::commit();

            return redirect()
                ->route('orders.index')
                ->with('flash', [
                    'message' => "Order {$order->custom_code} updated successfully"
                ]);

        } catch (\Exception $e) {
            DB::rollBack();
            
            return redirect()
                ->back()
                ->withInput()
                ->with('flash', [
                    'error' => 'Failed to update order: ' . $e->getMessage()
                ]);
        }
    }

    public function destroy(Order $order)
    {
        // Load event for better logging/messaging
        $order->load('event');
        $customCode = $order->custom_code;
        $eventType = $order->event ? $order->event->event_type : 'Unknown';

        DB::transaction(function () use ($order) {
            $order->venues()->detach();
            $order->delete();
        });

        return redirect()
            ->route('orders.index')
            ->with('flash', [
                'message' => "Order {$customCode} ({$eventType}) deleted successfully."
            ]);
    }

    public function calendar(Request $request)
    {
        // 1. Determine target month/year
        $month = (int) $request->query('month', now()->month);
        $year = (int) $request->query('year', now()->year);

        // 2. Get filter parameters
        $filterDate = $request->query('filter_date');
        $filterVenue = $request->query('filter_venue');
        $filterStatus = $request->query('filter_status');
        $filterEventType = $request->query('filter_event_type'); // Add event type filter

        // 3. Build month boundaries
        $startOfMonth = \Carbon\Carbon::create($year, $month, 1)->startOfMonth();
        $endOfMonth = $startOfMonth->copy()->endOfMonth();

        // 4. Fetch venues with short names
        $venues = Venue::select('id', 'name', 'short')->get();

        // 5. Fetch events for filter dropdown
        $events = Event::select('id', 'event_type', 'code')->orderBy('event_type', 'asc')->get();

        // 6. Build base query for orders with schedules overlapping the month
        $ordersQuery = Order::with(['venues', 'schedules', 'event:id,event_type,code', 'customer:id,organizer'])
            ->whereHas('schedules', function ($query) use ($startOfMonth, $endOfMonth) {
                $query->whereDate('start_date', '<=', $endOfMonth)
                    ->whereDate('end_date', '>=', $startOfMonth);
            });

        // 7. Apply filters
        if ($filterDate) {
            $ordersQuery->whereHas('schedules', function ($query) use ($filterDate) {
                $query->whereDate('start_date', '<=', $filterDate)
                    ->whereDate('end_date', '>=', $filterDate);
            });
        }

        if ($filterVenue) {
            $ordersQuery->whereHas('venues', function ($query) use ($filterVenue) {
                $query->where('venues.id', $filterVenue);
            });
        }

        if ($filterStatus !== null && $filterStatus !== '') {
            $ordersQuery->where('status', $filterStatus);
        }

        // Add event type filter
        if ($filterEventType) {
            $ordersQuery->whereHas('event', function ($query) use ($filterEventType) {
                $query->where('event_type', $filterEventType);
            });
        }

        $orders = $ordersQuery->get();

        // 8. Build per-venue calendar data
        $calendarData = $venues
            ->keyBy('id')
            ->map(function ($venue) {
                return [
                    'name' => $venue->name,
                    'short' => $venue->short,
                    'slots' => [],
                ];
            })
            ->toArray();

        foreach ($orders as $order) {
            foreach ($order->venues as $venue) {
                // Skip if venue filter is applied and this venue doesn't match
                if ($filterVenue && $venue->id != $filterVenue) {
                    continue;
                }

                foreach ($order->schedules as $schedule) {
                    // Check if schedule overlaps with the target month
                    $scheduleStart = \Carbon\Carbon::parse($schedule->start_date)->startOfDay();
                    $scheduleEnd = \Carbon\Carbon::parse($schedule->end_date)->startOfDay();

                    if ($scheduleStart->lte($endOfMonth) && $scheduleEnd->gte($startOfMonth)) {
                        // Apply date filter if specified
                        if ($filterDate) {
                            $filterDateCarbon = \Carbon\Carbon::parse($filterDate);
                            if (!($scheduleStart->lte($filterDateCarbon) && $scheduleEnd->gte($filterDateCarbon))) {
                                continue;
                            }
                        }

                        // Determine if it's a single day or multi-day event
                        $isSingleDay = $scheduleStart->isSameDay($scheduleEnd);

                        // Create display text with custom code and event type
                        $displayText = $order->custom_code . ' - ' . $order->event_name;
                        if ($order->event) {
                            $displayText .= ' (' . ucfirst($order->event->event_type) . ')';
                        }
                        if ($schedule->function) {
                            $displayText .= ' - ' . $schedule->function;
                        }

                        // Create date range for display
                        $dateRange = $isSingleDay
                            ? $scheduleStart->format('Y-m-d')
                            : $scheduleStart->format('Y-m-d') . ' to ' . $scheduleEnd->format('Y-m-d');

                        $calendarData[$venue->id]['slots'][] = [
                            'order_id' => $order->id,
                            'schedule_id' => $schedule->id,
                            'custom_code' => $order->custom_code, // Add custom code
                            'event_name' => $order->event_name,
                            'event_type' => $order->event ? $order->event->event_type : null, // Add event type
                            'event_code' => $order->event ? $order->event->code : null, // Add event code
                            'organizer' => $order->customer ? $order->customer->organizer : null, // Add organizer
                            'function' => $schedule->function,
                            'display_text' => $displayText,
                            'start' => $scheduleStart->format('Y-m-d'),
                            'end' => $scheduleEnd->format('Y-m-d'),
                            'is_single_day' => $isSingleDay,
                            'date_range' => $dateRange,
                            'status' => $order->status,
                            'status_beo' => $order->status_beo,
                            'date_span' => $this->generateDateSpan($scheduleStart, $scheduleEnd),
                        ];
                    }
                }
            }
        }

        // 9. Get unique event types for filter options
        $eventTypeOptions = $events->pluck('event_type')->unique()->sort()->map(function ($eventType) {
            return [
                'value' => $eventType,
                'label' => ucfirst($eventType)
            ];
        })->values();

        // 10. Render with Inertia including filter data
        $responseData = [
            'venues' => $venues,
            'events' => $events, // Add events for filter dropdown
            'calendarData' => $calendarData,
            'month' => $month,
            'year' => $year,
            'filters' => [
                'date' => $filterDate,
                'venue' => $filterVenue ? (int) $filterVenue : null,
                'status' => $filterStatus !== null && $filterStatus !== '' ? (int) $filterStatus : null,
                'event_type' => $filterEventType, // Add event type filter
            ],
            'statusOptions' => [
                ['value' => 0, 'label' => 'New Inquiry'],
                ['value' => 1, 'label' => 'Sudah Konfirmasi'],
                ['value' => 2, 'label' => 'Sudah dilaksanakan'],
            ],
            'statusBeoOptions' => [
                ['value' => 0, 'label' => 'Planning'],
                ['value' => 1, 'label' => 'Sudah Kirim Ke Kanit'],
                ['value' => 2, 'label' => 'Sudah Acc Kanit'],
                ['value' => 3, 'label' => 'Di edit'],
            ],
            'eventTypeOptions' => $eventTypeOptions, // Add event type options for filter
        ];

        return Inertia::render('orders/calendar', $responseData);
    }

    /**
     * Generate array of dates for multi-day events
     */
    private function generateDateSpan(\Carbon\Carbon $start, \Carbon\Carbon $end): array
    {
        $dates = [];
        $current = $start->copy()->startOfDay();
        $endDate = $end->copy()->startOfDay();

        while ($current->lte($endDate)) {
            $dates[] = $current->format('Y-m-d');
            $current->addDay();
        }

        return $dates;
    }

    public function updateStatus(Order $order)
    {
        // Load event for better messaging
        $order->load('event');
        
        $order->update(['status' => 1]);

        return redirect()
            ->route('orders.index')
            ->with('flash', [
                'message' => "Order {$order->custom_code} ({$order->event->event_type}) status confirmed."
            ]);
    }

    public function accKanit(Order $order)
    {
        // Load event for better messaging
        $order->load('event');
        
        $order->update(['status_beo' => 2]); // Changed to 2 (Sudah Acc Kanit)

        return redirect()
            ->route('orders.index')
            ->with('flash', [
                'message' => "Order {$order->custom_code} ({$order->event->event_type}) approved by Kanit."
            ]);
    }

    public function markSelesai(Order $order)
    {
        // Load event for better messaging
        $order->load('event');
        
        // Validate that the order can be marked as selesai
        // Only allow if status_beo is 2 (Sudah Acc Kanit)
        if ($order->status_beo !== 2) {
            return redirect()
                ->back()
                ->with('flash', [
                    'error' => 'Order cannot be marked as completed. BEO must be approved by Kanit first.'
                ]);
        }

        // Prevent marking as selesai if already completed
        if ($order->status === 2) {
            return redirect()
                ->back()
                ->with('flash', [
                    'error' => 'Order is already marked as completed.'
                ]);
        }

        // Update the order status to 2 (Sudah dilaksanakan)
        $order->update([
            'status' => 2
        ]);

        return redirect()
            ->route('orders.index')
            ->with('flash', [
                'message' => "Order {$order->custom_code} ({$order->event->event_type}) has been marked as completed."
            ]);
    }

    /**
     * Get orders by event type (API endpoint)
     */
    public function getByEventType(Request $request)
    {
        $eventType = $request->get('event_type');
        
        $orders = Order::with(['event:id,event_type,code', 'customer:id,organizer', 'venues:id,name'])
            ->whereHas('event', function ($query) use ($eventType) {
                $query->where('event_type', $eventType);
            })
            ->orderBy('created_at', 'desc')
            ->get();

        return response()->json($orders);
    }

    /**
     * Search orders by custom code
     */
    public function searchByCode(Request $request)
    {
        $code = $request->get('code');
        
        $orders = Order::with(['event:id,event_type,code', 'customer:id,organizer', 'venues:id,name'])
            ->where('custom_code', 'LIKE', "%{$code}%")
            ->orderBy('created_at', 'desc')
            ->get();

        return response()->json($orders);
    }

    /**
     * Get all event types (API endpoint)
     */
    public function getEventTypes()
    {
        $eventTypes = Event::select('event_type')
            ->distinct()
            ->orderBy('event_type', 'asc')
            ->pluck('event_type');

        return response()->json($eventTypes);
    }

    /**
     * Get events by type (API endpoint)
     */
    public function getEventsByType(Request $request)
    {
        $eventType = $request->get('event_type');
        
        $events = Event::select('id', 'event_type', 'code')
            ->where('event_type', $eventType)
            ->orderBy('code', 'asc')
            ->get();

        return response()->json($events);
    }

    /**
     * Get order statistics by event type
     */
    public function getEventTypeStats()
    {
        $stats = Order::with('event:id,event_type,code')
            ->selectRaw('event_id, COUNT(*) as total_orders, MAX(created_at) as latest_order')
            ->groupBy('event_id')
            ->get()
            ->map(function ($stat) {
                return [
                    'event_type' => $stat->event->event_type ?? 'Unknown',
                    'event_code' => $stat->event->code ?? 'Unknown',
                    'total_orders' => $stat->total_orders,
                    'latest_order' => $stat->latest_order,
                ];
            })
            ->sortByDesc('total_orders')
            ->values();

        return response()->json($stats);
    }
}